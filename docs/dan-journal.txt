What needs to be done in the bootloader function?
    - return a pointer to the gb_s global gameboy emulator context
    - load the ROM file and read its configuration
    - initialize all relevant members of that struct using the config read from the ROM
    - keep the ROM around so we can continue to extract instructions from it with the 'member functions'

Is it better to have a dedicated ROM struct?
    No, too much complexity. Everything should be accessed through the gb_s
    If we don't know the size of the ROM at boot time then we'll just leave it as a char* and allocate memory to it later.

We might actually want these files to be rom.c/h because we need to write access functions for the ROM

There is some inconsistency in the sizes of the RAM and the sizes of the address space

1. From the GB CPU Manual:
        /*
     * Extract the ROM size from the byte at 0x0148.
     * Address 0x0148 -> ROM size:
     * 0 - 256Kbit = 32KByte = 2 banks
     * 1 - 512Kbit = 64KByte = 4 banks
     * 2 - 1Mbit = 128KByte = 8 banks
     * 3 - 2Mbit = 256KByte = 16 banks
     * 4 - 4Mbit = 512KByte = 32 banks
     * 5 - 8Mbit = 1MByte = 64 banks
     * 6 - 16Mbit = 2MByte = 128 banks
     * 0x52 - 9Mbit = 1.1MByte = 72 banks
     * 0x53 - 10Mbit = 1.2MByte = 80 banks
     * 0x54 - 12Mbit = 1.5MByte = 96 banks
     */

2. From the gb_s struct definition:
        /**
     * Read byte from ROM
     * @param gb    Emulator context
     * @param addr  16-bit address to read from
     * @return      Byte at address
     */
    uint8_t (*gb_rom_read)(struct gb_s*, const uint32_t addr);

Obviously if the address space is 16 bit then we're not going to be able to address all the bytes.
The way this is solved is with "banking". The 16 bit address can "see" 2^16 = 65536 = 64 kB of ROM at any one time

What's actually going on here is that the 16-bit address space is being used by many different hardware things simultaneously
The table from the manual makes it obvious that one ROM bank is actually only 16 kB in size since 32KByte = 2 banks, 64KByte = 4 banks, etc.
What does the full memory map look like? What are the other addresses used for?

From the manual:

Interrupt Enable Register
--------------------------- FFFF
Internal RAM
--------------------------- FF80
Empty but unusable for I/O
--------------------------- FF4C
I/O ports
--------------------------- FF00
Empty but unusable for I/O
--------------------------- FEA0
Sprite Attrib Memory (OAM)
--------------------------- FE00
Echo of 8kB Internal RAM
--------------------------- E000
8kB Internal RAM
--------------------------- C000
8kB switchable RAM bank
--------------------------- A000
8kB Video RAM
--------------------------- 8000 --
16kB switchable ROM bank         |
--------------------------- 4000 |= 32kB Cartrigbe
16kB ROM bank #0                 |
--------------------------- 0000 --

So the 0th ROM bank is always loaded while the upper ROM bank is switchable. What controls this switching and how do we implement that in code?
The type of cart is important:

0x0147 Cartridge type (hex):
0-ROM ONLY 
1-ROM+MBC1 
2-ROM+MBC1+RAM 
3-ROM+MBC1+RAM+BATT 
5-ROM+MBC2 
6-ROM+MBC2+BATTERY 
8-ROM+RAM 
9-ROM+RAM+BATTERY 
B-ROM+MMM01 
C-ROM+MMM01+SRAM 
D-ROM+MMM01+SRAM+BATT 
F-ROM+MBC3+TIMER+BATT 
10-ROM+MBC3+TIMER+RAM+BATT
11-ROM+MBC3
12-ROM+MBC3+RAM
13-ROM+MBC3+RAM+BATT
19-ROM+MBC5
1A-ROM+MBC5+RAM
1B-ROM+MBC5+RAM+BATT
1C-ROM+MBC5+RUMBLE
1D-ROM+MBC5+RUMBLE+SRAM
1E-ROM+MBC5+RUMBLE+SRAM+BATT
1F-Pocket Camera
FD-Bandai TAMA5
FE-Hudson HuC-3
FF-Hudson HuC-1

The MBC type {1, 2, 5} controls how/if cart ram is used

Can we write gb_rom_read such that it can get this and other information in the bootloader before we're sure what the MBC is?
I don't want to have to interact with the file more than necessary; I still think loading the entire think into the gb_s struct is a good idea
We just need some way to keep track of what block the rom_read function is looking at
Probably the easiest way to do this is just have gb_rom_read take the block as an argument?

From the gb_s struct:
    uint8_t mbc;                    // MBC type (0=none, 1=MBC1)
    uint8_t cart_ram;               // 1 if cartridge has RAM
    uint16_t num_rom_banks_mask;    // Mask for ROM bank selection 
    uint8_t num_ram_banks;          // Number of RAM banks 
    
    uint16_t selected_rom_bank; // Current ROM bank
    uint8_t cart_ram_bank;      // Current RAM bank
    uint8_t enable_cart_ram;    // Cart RAM enable flag
    uint8_t cart_mode_select;   // MBC1 mode select

Seems like the peanutGB emulator only supports MBC1. This is a good way to de-scope our project too. 
Is it a good idea of have 'selected_rom_bank' and 'cart_ram_bank' or should we just use these as function arguments and store the whole thing in the gb_s?
I'm more partial to arguments since where else is this stuff going to go? 
It's simpler and better if we don't have to be swapping data in and out between gb_s and something else all the time.

All the config info is in ROM bank zero, therfore we should be able to configure everything in the bootloader by reading from that bank

so instead of the approach before where we scrap the block number vars in gb_s and just directly use them in function calls 
we should keep the block number because of the memory map
if a program tries to read from address >=2000 then that's going to read from whatever block is currently selected, need to account for this is ROM_READ

what are the different cart types and how those play with the gb_s settings?
we're only considering carts with no MBC or MBC0 which includes {0, 1, 2, 3, 8, 9}
"battery" means that the cart has a coincell that keeps the thing powered so it can non-volatile save progress (e.g. pokemon)
some of these options don't make a lot of sense
how can we have MBC but no RAM or RAM but no MBC?


from GPCPUman 2.6: 
    "MBC1 has two different maximum memory modes:
    16Mbit ROM/8KByte RAM or 4Mbit ROM/32KByte RAM"
These are the maximum total sizes of ROM and RAM for each case mode. The gameboy can have any combination below thse limits in each mode

RAM and NOT(MBC) {8, 9} =>
    The MBC is the device on the cartridge that controls switching between ROM and on-cartridge RAM banks.
    Without an MBC (modes 0x00, 0x08, 0x09) it is not possible to switch banks for ROM and on-cartridge RAM.
    In these modes (modes 0x00, 0x08, 0x09), the memory map is static meaning that reads or writes or some address in the ROM or on-cartridge RAM always address the same physical bytes
    There are no blocks to switch between, and the memory map contains enough space for two 16 kB blocks (block 0 and the selected block), 
    therefore the ROM size must be exactly 32 kB in all modes 0x00, 0x08, 0x09 cartridges. If there more another block, it could not be selected and addressed. 
    If there were one less block, there would be "empty space" in the selected ROM block at addresses [0x2000, 0x3FFF].
    The modes 0x08 and 0x09 dictate that there must be RAM on the cartridge, but that there is no MBC to switch between blocks of on-cartridge RAM. 
    These facts impose a constraint that there must be exactly one 8 kB block of RAM on the cartridge. 
    Any less and there would be zero block of on-cartridge RAM and the cartridge type would be 0x00. 
    Any more and not all blocks would be addressable because there is no MBC to switch to the other block.

NOT(RAM) and MBC {1} => 
    The NOT(RAM) condition simply means that the cart hardware itself has no RAM on it.
    The MBC can still change the selected ROM block, but reads/writes to cartridge RAM do nothing 

How do we tell how much RAM the cart has?
0149 RAM size:
0 - None
1 - 16kBit = 2kB = 1 bank
2 - 64kBit = 8kB = 1 bank
3 - 256kBit = 32kB = 4 banks
4 - 1MBit =128kB =16 banks

What's the deal with option 1 here?
The size of the address space for the cartridge RAM is 8 kB which is 1 block of cart ram
What happens in option 1 when we only have a quarter of the block?

What's the deal with addresses [0xFF80, 0xFFFF)?
These are the "HRAM" and are not part of the regular RAM
This is always of a fixed size with no blocking 
This RAM is like a CPU cache, very fast access but small

How should we actually manage accessing all this memory and IO if everything's just in the same address space?
    Option 1: 
        - have separate read and write functions for each type of hardware
        - each type of memory is stored in its own array that is sized just for itself
        - pass the global address of the object to any of the read/write functions
        - the read/write functions apply an appropriate offset for the thing they are trying to access

        do we still need separate read/write for on-cart vs external RAM?
        probably. Even though these do basically the same thing, gb_types has wram[WRAM_SIZE] fixed at 2kB
        if necessary later we can wrap these both in a "read_ram" function that reads internal or on-cart based on the address

        what are we going to do about the 2kB cart RAM case? what is num_cart_ram_banks going to be?
        maybe some special define value that will never be reached otherwise?
        the other options is to just add a separate variable for a flag, that's less clean imo