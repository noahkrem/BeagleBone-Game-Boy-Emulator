What needs to be done in the bootloader function?
    - return a pointer to the gb_s global gameboy emulator context
    - load the ROM file and read its configuration
    - initialize all relevant members of that struct using the config read from the ROM
    - keep the ROM around so we can continue to extract instructions from it with the 'member functions'

Is it better to have a dedicated ROM struct?
    No, too much complexity. Everything should be accessed through the gb_s
    If we don't know the size of the ROM at boot time then we'll just leave it as a char* and allocate memory to it later.

We might actually want these files to be rom.c/h because we need to write access functions for the ROM

There is some inconsistency in the sizes of the RAM and the sizes of the address space

1. From the GB CPU Manual:
        /*
     * Extract the ROM size from the byte at 0x0148.
     * Address 0x0148 -> ROM size:
     * 0 - 256Kbit = 32KByte = 2 banks
     * 1 - 512Kbit = 64KByte = 4 banks
     * 2 - 1Mbit = 128KByte = 8 banks
     * 3 - 2Mbit = 256KByte = 16 banks
     * 4 - 4Mbit = 512KByte = 32 banks
     * 5 - 8Mbit = 1MByte = 64 banks
     * 6 - 16Mbit = 2MByte = 128 banks
     * 0x52 - 9Mbit = 1.1MByte = 72 banks
     * 0x53 - 10Mbit = 1.2MByte = 80 banks
     * 0x54 - 12Mbit = 1.5MByte = 96 banks
     */

2. From the gb_s struct definition:
        /**
     * Read byte from ROM
     * @param gb    Emulator context
     * @param addr  16-bit address to read from
     * @return      Byte at address
     */
    uint8_t (*gb_rom_read)(struct gb_s*, const uint32_t addr);

Obviously if the address space is 16 bit then we're not going to be able to address all the bytes.
The way this is solved is with "banking". The 16 bit address can "see" 2^16 = 65536 = 64 kB of ROM at any one time

What's actually going on here is that the 16-bit address space is being used by many different hardware things simultaneously
The table from the manual makes it obvious that one ROM bank is actually only 16 kB in size since 32KByte = 2 banks, 64KByte = 4 banks, etc.
What does the full memory map look like? What are the other addresses used for?

From the manual:

Interrupt Enable Register
--------------------------- FFFF
Internal RAM
--------------------------- FF80
Empty but unusable for I/O
--------------------------- FF4C
I/O ports
--------------------------- FF00
Empty but unusable for I/O
--------------------------- FEA0
Sprite Attrib Memory (OAM)
--------------------------- FE00
Echo of 8kB Internal RAM
--------------------------- E000
8kB Internal RAM
--------------------------- C000
8kB switchable RAM bank
--------------------------- A000
8kB Video RAM
--------------------------- 8000 --
16kB switchable ROM bank         |
--------------------------- 4000 |= 32kB Cartrigbe
16kB ROM bank #0                 |
--------------------------- 0000 --

So the 0th ROM bank is always loaded while the upper ROM bank is switchable. What controls this switching and how do we implement that in code?
The type of cart is important:

0x0147 Cartridge type (hex):
0-ROM ONLY 
1-ROM+MBC1 
2-ROM+MBC1+RAM 
3-ROM+MBC1+RAM+BATT 
5-ROM+MBC2 
6-ROM+MBC2+BATTERY 
8-ROM+RAM 
9-ROM+RAM+BATTERY 
B-ROM+MMM01 
C-ROM+MMM01+SRAM 
D-ROM+MMM01+SRAM+BATT 
F-ROM+MBC3+TIMER+BATT 
10-ROM+MBC3+TIMER+RAM+BATT
11-ROM+MBC3
12-ROM+MBC3+RAM
13-ROM+MBC3+RAM+BATT
19-ROM+MBC5
1A-ROM+MBC5+RAM
1B-ROM+MBC5+RAM+BATT
1C-ROM+MBC5+RUMBLE
1D-ROM+MBC5+RUMBLE+SRAM
1E-ROM+MBC5+RUMBLE+SRAM+BATT
1F-Pocket Camera
FD-Bandai TAMA5
FE-Hudson HuC-3
FF-Hudson HuC-1

The MBC type {1, 2, 5} controls how/if cart ram is used

Can we write gb_rom_read such that it can get this and other information in the bootloader before we're sure what the MBC is?
I don't want to have to interact with the file more than necessary; I still think loading the entire think into the gb_s struct is a good idea
We just need some way to keep track of what block the rom_read function is looking at
Probably the easiest way to do this is just have gb_rom_read take the block as an argument?

From the gb_s struct:
    uint8_t mbc;                    // MBC type (0=none, 1=MBC1)
    uint8_t cart_ram;               // 1 if cartridge has RAM
    uint16_t num_rom_banks_mask;    // Mask for ROM bank selection 
    uint8_t num_ram_banks;          // Number of RAM banks 
    
    uint16_t selected_rom_bank; // Current ROM bank
    uint8_t cart_ram_bank;      // Current RAM bank
    uint8_t enable_cart_ram;    // Cart RAM enable flag
    uint8_t cart_mode_select;   // MBC1 mode select

Seems like the peanutGB emulator only supports MBC1. This is a good way to de-scope our project too. 
Is it a good idea of have 'selected_rom_bank' and 'cart_ram_bank' or should we just use these as function arguments and store the whole thing in the gb_s?
I'm more partial to arguments since where else is this stuff going to go? 
It's simpler and better if we don't have to be swapping data in and out between gb_s and something else all the time.

All the config info is in ROM bank zero, therfore we should be able to configure everything in the bootloader by reading from that bank